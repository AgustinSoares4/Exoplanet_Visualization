<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Exoplanet Discoveries Timeline</title>
  <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
  <style>
    body {
      background-color: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }

    /* Fondo espacial con estrellas */
    #space-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, #0a0e23 0%, #000000 100%);
      z-index: -10;
      overflow: hidden;
    }

    .star {
      position: absolute;
      background-color: #fff;
      border-radius: 50%;
      opacity: 0.8;
      animation: twinkle 4s infinite ease-in-out;
    }

    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    #timeline {
      width: 100%;
      height: 600px;
      margin: 0 auto;
      border: 2px solid #333;
      border-radius: 10px;
      box-shadow: 0 0 25px rgba(100, 150, 255, 0.3);
      position: relative;
      overflow: hidden;
      /* Let Plotly handle the cursor for points */
      /* cursor: default !important; */
    }

    /* Allow pointer cursor on plot elements */
    .plotly .cursor-pointer {
        cursor: pointer !important;
    }

    .button-container {
      display: flex;
      justify-content: center;
      margin-top: 20px;
      gap: 30px;
    }

    .arrow-button {
      background-color: rgba(68, 68, 68, 0.7);
      color: #fff;
      border: 1px solid #777;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      font-size: 28px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5), 0 0 15px rgba(100, 150, 255, 0.3);
      transition: all 0.3s ease;
    }

    .arrow-button:hover {
      background-color: rgba(100, 150, 255, 0.4);
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(100, 150, 255, 0.7);
    }

    .arrow-button:active {
      transform: scale(0.95);
    }

    /* Estilos para la tarjeta de planeta - Modificado para centrarse en la gráfica */
    #planet-card {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      width: 300px;
      height: auto;
      max-height: 80vh;
      background: linear-gradient(145deg, rgba(20, 40, 80, 0.95) 0%, rgba(10, 20, 40, 0.98) 100%);
      border-radius: 15px;
      border: 2px solid rgba(100, 150, 255, 0.6);
      box-shadow: 0 0 40px rgba(100, 150, 255, 0.5), inset 0 0 30px rgba(100, 150, 255, 0.2);
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      z-index: 1000;
      opacity: 0;
      transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                  opacity 0.5s ease-in-out;
      overflow: hidden;
      pointer-events: none;
    }

    #planet-card.visible {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
      pointer-events: auto;
    }

    .planet-name {
      font-size: 1.8em;
      color: #FFD700;
      margin-bottom: 10px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    .planet-image-container {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      overflow: hidden;
      margin: 10px 0;
      border: 3px solid rgba(100, 150, 255, 0.6);
      box-shadow: 0 0 20px rgba(100, 150, 255, 0.6);
      background: radial-gradient(circle at 65% 15%, rgba(255, 255, 255, 0.1) 1px, transparent 3%),
                  radial-gradient(circle at 30% 40%, rgba(255, 255, 255, 0.2) 1px, transparent 4%),
                  radial-gradient(circle at 70% 90%, rgba(255, 255, 255, 0.1) 1px, transparent 2%);
      position: relative;
    }

    .card-shine {
      position: absolute;
      top: 0;
      left: -100%;
      width: 80%;
      height: 100%;
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.1) 25%,
        rgba(255, 255, 255, 0.2) 50%,
        rgba(255, 255, 255, 0.1) 75%,
        rgba(255, 255, 255, 0) 100%
      );
      transform: skewX(-15deg);
      animation: card-shine-animation 3s ease-in-out infinite;
    }

    @keyframes card-shine-animation {
      0% { left: -100%; }
      20% { left: 100%; }
      100% { left: 100%; }
    }

    .planet-year {
      font-size: 1.1em;
      color: #adf;
      margin-bottom: 20px;
      display: block;
    }

    .planet-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      width: 100%;
    }

    .stat {
      background-color: rgba(30, 60, 100, 0.6);
      border-radius: 8px;
      padding: 10px 5px;
      border: 1px solid rgba(100, 150, 255, 0.4);
      transition: all 0.3s ease;
    }

    .stat:hover {
      background-color: rgba(40, 80, 120, 0.7);
      transform: translateY(-3px);
    }

    .stat-name {
      color: #adf;
      font-size: 0.85em;
      margin-bottom: 5px;
      display: block;
    }

    .stat-value {
      font-size: 1.1em;
      font-weight: bold;
    }

    .planet-type {
      position: absolute;
      top: 5px;
      right: 5px;
      background-color: rgba(255, 215, 0, 0.8);
      color: #000;
      padding: 3px 8px;
      border-radius: 10px;
      font-size: 0.7em;
      font-weight: bold;
    }

    #header {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.2em;
      color: #adf;
      text-shadow: 0 0 10px rgba(100, 150, 255, 0.8);
    }

    /* Botón para cerrar la tarjeta */
    .close-button {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 30px;
      height: 30px;
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 16px;
      color: white;
    }

    .close-button:hover {
      background-color: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }

    /* Overlay para cuando la carta está abierta */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 900;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    #overlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    /* Contenedor principal */
    .container {
      display: flex;
      position: relative;
    }

    .main-content {
      flex-grow: 1;
      position: relative; /* Para posicionamiento absoluto de planet-card */
    }
  </style>
</head>
<body>
  <!-- Fondo espacial -->
  <div id="space-background"></div>
  <div id="overlay"></div>

  <div id="header">
    <h1>Exoplanet Discoveries Timeline</h1>
    <p>Explore planets with high Earth Similarity Index (ESI) discovered over the years</p>
  </div>

  <div class="container">
    <div class="main-content">
      <div id="timeline"></div>

      <!-- Tarjeta de planeta dentro de la gráfica -->
      <div id="planet-card">
        <div class="close-button">&times;</div>
        <div class="planet-name">Planet Name</div>
        <div class="planet-image-container">
          <div class="planet-type">Earth-like</div>
          <canvas id="planet-canvas" width="180" height="180"></canvas>
          <div class="card-shine"></div>
        </div>
        <span class="planet-year">Discovered in: 2000</span>
        <div class="planet-stats">
          <div class="stat">
            <span class="stat-name">ESI</span>
            <span class="stat-value">0.00</span>
          </div>
          <div class="stat">
            <span class="stat-name">Radius</span>
            <span class="stat-value">0.0 R⊕</span>
          </div>
          <div class="stat">
            <span class="stat-name">Temperature</span>
            <span class="stat-value">Unknown</span>
          </div>
          <div class="stat">
            <span class="stat-name">Distance</span>
            <span class="stat-value">Unknown</span>
          </div>
        </div>
      </div>

      <div class="button-container">
        <button id="prev" class="arrow-button">&larr;</button>
        <button id="next" class="arrow-button">&rarr;</button>
      </div>
    </div>
  </div>

  <script>
    // Variable para controlar el temporizador de la tarjeta del planeta
    let planetCardTimer = null;

    // Crear estrellas para el fondo espacial
    function createStars() {
      const background = document.getElementById('space-background');
      const starCount = 200; // Número de estrellas

      for (let i = 0; i < starCount; i++) {
        const star = document.createElement('div');
        star.className = 'star';

        // Tamaño aleatorio (mayormente pequeñas)
        const size = Math.random() * 3;
        star.style.width = size + 'px';
        star.style.height = size + 'px';

        // Posición aleatoria
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';

        // Retraso aleatorio en la animación de parpadeo
        star.style.animationDelay = Math.random() * 4 + 's';

        background.appendChild(star);
      }
    }

    // Ejecutar la creación de estrellas al cargar
    createStars();

    // Variables globales
    let data = []; // Datos cargados desde timeline.json
    let filteredData = []; // Datos filtrados (un planeta por año con el mayor ESI)
    let currentYearIndex = 0; // Índice actual del año mostrado
    let previousYearIndex = 0; // Para rastrear la dirección de navegación

    // Arrays para almacenar los datos de los planetas
    const planetsData = [];

    // Color fijo para los planetas (azul brillante)
    const PLANET_COLOR = 'rgb(80, 200, 255)';
    // Color destacado para el planeta actual (amarillo brillante)
    const HIGHLIGHT_COLOR = 'rgb(255, 215, 0)';
    // Factor de aumento para el tamaño del planeta destacado
    const SIZE_MULTIPLIER = 2.5;

    // Inicializar la gráfica con ejes estáticos
    const layout = {
      title: {
        text: '',
        font: {
          color: '#FFD700',
          size: 24
        }
      },
      paper_bgcolor: 'rgba(0,0,0,0)',
      plot_bgcolor: 'rgba(0,0,0,0)',
      xaxis: {
        title: {
          text: 'Year of Discovery',
          font: {
            color: '#adf',
            size: 14
          }
        },
        tickfont: {
          color: '#adf'
        },
        showgrid: false,
        tickmode: 'array',
        tickvals: [2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024],
        range: [2010, 2025]
      },
      yaxis: {
        title: {
          text: 'Earth Similarity Index (ESI)',
          font: {
            color: '#adf',
            size: 14
          }
        },
        tickfont: {
          color: '#adf'
        },
        showgrid: false,
        range: [0, 1]
      },
      hovermode: 'closest', // Enable hovermode to help with click detection
      dragmode: false // Deshabilitar arrastrar
    };

    // Configuración para Plotly
    const config = {
      displayModeBar: false, // Ocultar barra de herramientas
      responsive: true,      // Hacer la gráfica responsiva
      scrollZoom: false,     // Deshabilitar el zoom con desplazamiento
      showTips: false,       // No mostrar consejos
      modeBarButtonsToRemove: ['select2d', 'lasso2d'] // Remove selection tools
    };

    // Crear la gráfica inicial con ejes estáticos
    Plotly.newPlot('timeline', [{
      x: [],
      y: [],
      mode: 'markers',
      type: 'scatter',
      marker: {
        size: [],
        color: PLANET_COLOR,
        showscale: false,
        line: {
          color: 'rgba(100, 150, 255, 0.5)',
          width: 1
        },
        opacity: 0.8
      },
      text: [],
      hoverinfo: 'none' // Keep hover info off visually
    }], layout, config);

    // Cargar los datos desde timeline.json
    fetch('timeline.json')
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(jsonData => {
        data = jsonData;

        // Filtrar los datos para obtener el planeta con el mayor ESI por año
        const planetsByYear = {};
        data.forEach(planet => {
          const year = planet.disc_year;
          // Ensure ESI is a number, default to 0 if missing or invalid
          const esiValue = (typeof planet.ESI === 'number' && !isNaN(planet.ESI)) ? planet.ESI : 0;
          if (!planetsByYear[year] || esiValue > planetsByYear[year].ESI) {
            planetsByYear[year] = { ...planet, ESI: esiValue }; // Store the validated ESI
          }
        });

        // Convertir el objeto en una lista ordenada por año
        filteredData = Object.values(planetsByYear).sort((a, b) => a.disc_year - b.disc_year);

        // Preprocesar los datos de los planetas
        planetsData.length = 0; // Clear previous data if any
        for (let i = 0; i < filteredData.length; i++) {
          const planet = filteredData[i];
          planetsData.push({
            x: planet.disc_year,
            y: Math.max(0, planet.ESI), // Use the validated ESI
            baseSize: (planet.pl_rade || 1) * 10,
            text: `Planet: ${planet.pl_name}<br>Year: ${planet.disc_year}<br>ESI: ${planet.ESI.toFixed(2)}<br>Radius: ${planet.pl_rade || 'N/A'} Earth radii`
          });
        }

        // Inicializar la gráfica con el primer planeta
        updateTimeline();

        // Agregar evento para detectar clics en los planetas
        const plotDiv = document.getElementById('timeline');
        plotDiv.on('plotly_click', function(eventData) {
          console.log('Plotly Click Event Data:', eventData); // Log event data for debugging
          // Si se hizo clic en un punto
          if (eventData.points && eventData.points.length > 0) {
            // Obtener el índice del punto en que se hizo clic
            // pointNumber refers to the index in the data array of the trace
            const pointIndex = eventData.points[0].pointNumber;
            console.log('Clicked Point Index:', pointIndex); // Log the index

            // Si el punto existe en nuestros datos filtrados y es visible
            if (pointIndex >= 0 && pointIndex < filteredData.length && pointIndex <= currentYearIndex) {
              console.log('Showing card for planet:', filteredData[pointIndex].pl_name);
              // Mostrar la tarjeta del planeta
              showPlanetCard(filteredData[pointIndex]);

              // Cancelar cualquier temporizador existente para evitar que se abra la tarjeta automáticamente
              if (planetCardTimer) {
                clearTimeout(planetCardTimer);
                planetCardTimer = null;
                console.log('Automatic card timer cancelled.');
              }
            } else {
              console.log('Clicked point index out of range or not visible yet:', pointIndex);
            }
          } else {
             console.log('Click event detected, but no points found in event data.');
          }
        });

      })
      .catch(error => {
          console.error('Error loading or processing timeline.json:', error);
          // Optionally display an error message to the user
          const header = document.getElementById('header');
          const errorMsg = document.createElement('p');
          errorMsg.style.color = 'red';
          errorMsg.textContent = 'Error loading planet data. Please check the console for details.';
          header.appendChild(errorMsg);
      });

    // Función para actualizar la línea de tiempo
    function updateTimeline() {
      // Cancelar cualquier temporizador existente para mostrar la tarjeta
      if (planetCardTimer) {
        clearTimeout(planetCardTimer);
        planetCardTimer = null;
      }

      // Cerrar la tarjeta si está abierta (antes de la animación)
      closePlanetCard();

      if (currentYearIndex >= 0 && currentYearIndex < filteredData.length) {
        const planet = filteredData[currentYearIndex];

        // Determinar dirección de navegación
        const isForward = currentYearIndex >= previousYearIndex;
        previousYearIndex = currentYearIndex;

        // Crear arrays para mostrar solo hasta el índice actual
        const visibleX = [];
        const visibleY = [];
        const visibleSizes = [];
        const visibleColors = [];
        const visibleTexts = [];

        // Acumular solo hasta el índice actual
        for (let i = 0; i <= currentYearIndex; i++) {
          if (planetsData[i]) { // Check if data exists for this index
            visibleX.push(planetsData[i].x);
            visibleY.push(planetsData[i].y);

            // Si es el planeta actual, hacerlo más grande y destacarlo
            if (i === currentYearIndex) {
              visibleSizes.push(planetsData[i].baseSize * SIZE_MULTIPLIER);
              visibleColors.push(HIGHLIGHT_COLOR);
            } else {
              visibleSizes.push(planetsData[i].baseSize);
              visibleColors.push(PLANET_COLOR);
            }
            visibleTexts.push(planetsData[i].text);
          } else {
             console.warn(`Missing planet data for index ${i}`);
          }
        }

        // Actualizar la gráfica con los planetas visibles
        Plotly.react('timeline', [{
          x: visibleX,
          y: visibleY,
          mode: 'markers',
          type: 'scatter',
          marker: {
            size: visibleSizes,
            color: visibleColors,
            showscale: false,
            line: {
              color: 'rgba(100, 150, 255, 0.5)',
              width: 1
            },
            opacity: 0.8,
            symbol: 'circle' // Ensure points are circles
          },
          text: visibleTexts,
          hoverinfo: 'none'  // Keep hover info off visually
        }], layout, {
          transition: {
            duration: 800,
            easing: 'cubic-in-out'
          },
          frame: {
            duration: 800
          }
        }).then(() => {
            // Ensure cursor is set after plot update
            setPointCursor();
        });

        // Configurar temporizador para mostrar la tarjeta del planeta actual después de 1 segundo
        // Solo si la tarjeta no fue abierta por un clic reciente
        if (!document.getElementById('planet-card').classList.contains('visible')) {
            planetCardTimer = setTimeout(() => {
                console.log('Automatic timer showing card for:', planet.pl_name);
                showPlanetCard(planet);
                planetCardTimer = null; // Clear timer reference after execution
            }, 1000); // Show card after 1 second
        }

      } else {
        console.error('Invalid year index:', currentYearIndex);
      }
    }

    // Function to specifically set pointer cursor on plot points
    function setPointCursor() {
        const points = document.querySelectorAll('#timeline .scatterlayer .trace .points path');
        points.forEach(point => {
            point.style.cursor = 'pointer';
        });
        // Also set default cursor for the plot background itself
        const plotBg = document.querySelector('#timeline .plot-container .svg-container');
        if (plotBg) {
            plotBg.style.cursor = 'default';
        }
    }


    // Función para mostrar y animar la tarjeta del planeta
    function showPlanetCard(planet) {
      if (!planet) {
          console.error("showPlanetCard called with invalid planet data:", planet);
          return;
      }
      const planetCard = document.getElementById('planet-card');
      const overlay = document.getElementById('overlay');

      // Actualizar contenido
      planetCard.querySelector('.planet-name').textContent = planet.pl_name || 'Unknown Planet';
      planetCard.querySelector('.planet-year').textContent = `Discovered in ${planet.disc_year || 'N/A'}`;

      const stats = planetCard.querySelectorAll('.stat-value');
      // Ensure ESI is a number before calling toFixed
      const esiValue = (typeof planet.ESI === 'number' && !isNaN(planet.ESI)) ? planet.ESI.toFixed(2) : 'N/A';
      stats[0].textContent = esiValue;
      stats[1].textContent = planet.pl_rade ? `${planet.pl_rade.toFixed(1)} R⊕` : 'Unknown';
      stats[2].textContent = planet.pl_eqt ? `${planet.pl_eqt} K` : 'Unknown';
      stats[3].textContent = planet.sy_dist ? `${planet.sy_dist.toFixed(1)} pc` : 'Unknown';

      // Determinar el tipo de planeta según el ESI
      const planetType = document.querySelector('.planet-type');
      const esiNum = (typeof planet.ESI === 'number' && !isNaN(planet.ESI)) ? planet.ESI : -1; // Use -1 if not a number

      if (esiNum >= 0.8) {
        planetType.textContent = "Very Earth-like";
        planetType.style.backgroundColor = "rgba(0, 255, 0, 0.8)";
      } else if (esiNum >= 0.6) {
        planetType.textContent = "Earth-like";
        planetType.style.backgroundColor = "rgba(255, 215, 0, 0.8)";
      } else if (esiNum >= 0) { // Only show if ESI is known and >= 0
        planetType.textContent = "Potentially habitable";
        planetType.style.backgroundColor = "rgba(255, 165, 0, 0.8)";
      } else {
         planetType.textContent = "Unknown Type";
         planetType.style.backgroundColor = "rgba(128, 128, 128, 0.8)"; // Grey for unknown
      }

      // Generar imagen del planeta
      generatePlanetImage(planet);

      // Mostrar la tarjeta y el overlay con animación
      overlay.classList.add('active');
      planetCard.classList.add('visible');
    }

    // Función para cerrar la tarjeta del planeta
    function closePlanetCard() {
      const planetCard = document.getElementById('planet-card');
      const overlay = document.getElementById('overlay');

      planetCard.classList.remove('visible');
      overlay.classList.remove('active');
    }

    // Configurar el evento de cierre de la tarjeta
    document.querySelector('.close-button').addEventListener('click', closePlanetCard);
    document.getElementById('overlay').addEventListener('click', closePlanetCard);

    // Función para generar una imagen de planeta basada en sus características
    function generatePlanetImage(planet) {
      const canvas = document.getElementById('planet-canvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;

      // Limpiar el canvas
      ctx.clearRect(0, 0, width, height);

      // Calcular el color base del planeta basado en el ESI
      let r, g, b;
      const esiNum = (typeof planet.ESI === 'number' && !isNaN(planet.ESI)) ? planet.ESI : 0.5; // Default to 0.5 if unknown

      if (esiNum >= 0.8) {
        // Muy similar a la Tierra
        r = 30 + Math.random() * 50;
        g = 100 + Math.random() * 80;
        b = 180 + Math.random() * 60;
      } else if (esiNum >= 0.6) {
        // Bastante similar
        r = 70 + Math.random() * 60;
        g = 140 + Math.random() * 60;
        b = 100 + Math.random() * 80;
      } else {
        // Menos similar o desconocido
        r = 140 + Math.random() * 100;
        g = 80 + Math.random() * 80;
        b = 40 + Math.random() * 50;
      }

      // Radio del planeta
      const radius = width / 2 - 2;

      // Dibujar el planeta base (círculo)
      const gradient = ctx.createRadialGradient(
        width / 2, height / 2, 0,
        width / 2, height / 2, radius
      );

      // Centro más brillante, borde más oscuro
      gradient.addColorStop(0, `rgba(${r+30}, ${g+30}, ${b+30}, 1)`);
      gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 1)`);
      gradient.addColorStop(0.9, `rgba(${r*0.7}, ${g*0.7}, ${b*0.7}, 1)`);
      gradient.addColorStop(1, `rgba(${r*0.5}, ${g*0.5}, ${b*0.5}, 1)`);

      ctx.beginPath();
      ctx.arc(width / 2, height / 2, radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      // Agregar características basadas en el planeta
      if (esiNum >= 0.7) {
        ctx.globalCompositeOperation = "overlay";

        // Dibujar "continentes" con formas orgánicas
        const numberOfContinents = 3 + Math.floor(Math.random() * 5);

        ctx.fillStyle = `rgba(${r*0.7}, ${g*1.3}, ${b*0.7}, 0.5)`;

        for (let i = 0; i < numberOfContinents; i++) {
          // Punto central del continente
          const angle = Math.random() * Math.PI * 2;
          const distFromCenter = radius * (0.2 + Math.random() * 0.7);
          const x = width/2 + Math.cos(angle) * distFromCenter;
          const y = height/2 + Math.sin(angle) * distFromCenter;

          // Tamaño del continente
          const continentSize = radius * (0.2 + Math.random() * 0.3);

          // Dibujar forma irregular
          ctx.beginPath();
          ctx.moveTo(x, y);

          for (let j = 0; j < 8; j++) {
            const ang = (j / 8) * Math.PI * 2;
            const rad = continentSize * (0.7 + Math.random() * 0.6);
            const xPoint = x + Math.cos(ang) * rad;
            const yPoint = y + Math.sin(ang) * rad;
            ctx.lineTo(xPoint, yPoint);
          }

          ctx.closePath();
          ctx.fill();
        }
      }
      else { // For less Earth-like or unknown ESI, draw bands
        ctx.globalCompositeOperation = "overlay";

        // Número de bandas
        const numberOfBands = 3 + Math.floor(Math.random() * 4);

        for (let i = 0; i < numberOfBands; i++) {
          // Ancho aleatorio para cada banda
          const bandWidth = radius * (0.1 + Math.random() * 0.2);
          // const bandPos = -radius + (i * radius * 2 / numberOfBands); // Position not needed for ellipse

          // Color aleatorio para la banda
          const bandR = Math.min(255, r * (0.8 + Math.random() * 0.6));
          const bandG = Math.min(255, g * (0.8 + Math.random() * 0.6));
          const bandB = Math.min(255, b * (0.8 + Math.random() * 0.6));

          ctx.fillStyle = `rgba(${bandR}, ${bandG}, ${bandB}, 0.5)`;

          ctx.beginPath();
          // Draw ellipse as a band - adjust rotation angle for variety if needed
          ctx.ellipse(width/2, height/2, radius, bandWidth, Math.random() * Math.PI, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Restaurar modo de composición
      ctx.globalCompositeOperation = "source-over";

      // Agregar brillo/atmósfera
      const glowGradient = ctx.createRadialGradient(
        width / 2, height / 2, radius * 0.8,
        width / 2, height / 2, radius + 10
      );
      glowGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0)`);
      glowGradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.03)`);
      glowGradient.addColorStop(0.8, `rgba(${r}, ${g}, ${b}, 0.05)`);
      glowGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

      ctx.beginPath();
      ctx.arc(width / 2, height / 2, radius + 10, 0, Math.PI * 2);
      ctx.fillStyle = glowGradient;
      ctx.fill();

      // Agregar iluminación en un lado
      const highlightGradient = ctx.createRadialGradient(
        width / 2 - radius * 0.5, height / 2 - radius * 0.5, 0,
        width / 2, height / 2, radius
      );
      highlightGradient.addColorStop(0, `rgba(255, 255, 255, 0.2)`);
      highlightGradient.addColorStop(0.5, `rgba(255, 255, 255, 0.05)`);
      highlightGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);

      ctx.globalCompositeOperation = "overlay"; // Use overlay for subtle highlight
      ctx.beginPath();
      ctx.arc(width / 2, height / 2, radius, 0, Math.PI * 2);
      ctx.fillStyle = highlightGradient;
      ctx.fill();

      // Restore default composite operation
      ctx.globalCompositeOperation = "source-over";
    }

    // Función para manejar el botón "Previous"
    document.getElementById('prev').addEventListener('click', () => {
      if (currentYearIndex > 0) {
        currentYearIndex--;
        updateTimeline();
        animateButton('prev');
      } else {
        shakeButton('prev');
      }
    });

    // Función para manejar el botón "Next"
    document.getElementById('next').addEventListener('click', () => {
      if (currentYearIndex < filteredData.length - 1) {
        currentYearIndex++;
        updateTimeline();
        animateButton('next');
      } else {
        shakeButton('next');
      }
    });

    // Función para animar un botón cuando se hace clic
    function animateButton(buttonId) {
      const button = document.getElementById(buttonId);
      button.style.transform = 'scale(1.2)';
      button.style.boxShadow = '0 0 25px rgba(100, 150, 255, 0.8)';

      setTimeout(() => {
        button.style.transform = 'scale(1)';
        button.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.5), 0 0 15px rgba(100, 150, 255, 0.3)';
      }, 200);
    }

    // Función para agitar un botón cuando se llega al límite
    function shakeButton(buttonId) {
      const button = document.getElementById(buttonId);
      button.style.animation = 'shake 0.5s';

      setTimeout(() => {
        button.style.animation = '';
      }, 500);
    }

    // Añadir animación de agitar
    const styleElement = document.createElement('style');
    styleElement.textContent = `
      @keyframes shake {
        0% { transform: translateX(0); }
        25% { transform: translateX(-6px); }
        50% { transform: translateX(6px); }
        75% { transform: translateX(-6px); }
        100% { transform: translateX(0); }
      }
    `;
    document.head.appendChild(styleElement);

    // Set cursor initially and observe changes
    window.addEventListener('load', () => {
        setPointCursor(); // Set initial cursor

        // Observer to re-apply cursor style if Plotly redraws/modifies points
        const observer = new MutationObserver((mutationsList, observer) => {
            // Look for changes within the scatter layer
            for(const mutation of mutationsList) {
                if (mutation.target.classList.contains('scatterlayer') || mutation.addedNodes.length > 0) {
                    setPointCursor();
                    break; // No need to check further mutations in this batch
                }
            }
        });

        const timelinePlot = document.getElementById('timeline');
        if (timelinePlot) {
            observer.observe(timelinePlot, { childList: true, subtree: true });
        }
    });

  </script>
</body>
</html>
